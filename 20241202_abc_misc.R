# current idea is to create a tree until generation 4 
# there you select ICM cells
# you then add trees for the selected cells
# you split the cells after n ICM divisions to obtain twins
tree1 = make_tree(4)
# we will do a temporary label to make sure we can track this correctly bc im stupid and cannot do this otherwise
node_depths = node.depth(tree1)
nodes_to_icm = which(node_depths == 1) # 16 cells to choose from (at the last layer)
cells_to_icm = sample(nodes_to_icm, 3) # select 3 cells from 16 to make ICM
cells_non_icm = setdiff(nodes_to_icm, cells_to_icm) # rest of the cell contributes to the trophoblast

# check that you select nodes at the right level 
plot.phylo(tree1)
nodelabels(cells_to_icm, cells_to_icm) # yes that looks about right 

# simulate an additional tree for extra few divisions and add it to each cell selected to the ICM
tree2 = make_tree(3)
tree3 = bind.tree(tree1, tree2, where = cells_to_icm[1])
if (is.null(tree3$edge.length)){
  tree3$edge.length = rep(1, nrow(tree3$edge))
}
plot.phylo(tree3)
nodelabels( col = 'purple')

tree3 = bind.tree(tree3, tree2, where = cells_to_icm[2])
if (is.null(tree3$edge.length)){
  tree3$edge.length = rep(1, nrow(tree3$edge))
}
plot.phylo(tree3)
nodelabels( col = 'purple')

tree3 = bind.tree(tree3, tree2, where = cells_to_icm[3])
if (is.null(tree3$edge.length)){
  tree3$edge.length = rep(1, nrow(tree3$edge))
}
plot.phylo(tree3)
nodelabels( col = 'purple')
# okay that actually worked!!

# I guess I can add the mutations now
mu1 = 2
mu2 = 1
tree3$edge.length = rpois(lambda=mu2,n=nrow(tree3$edge)) # add mutations onto each branch of the tree (sample from Poisson distribution with lambda = mutation rate after ZGA)
tree3$edge.length[tree3$edge[,2]%in%c(find_nodes_gen(1, tree=tree3),find_nodes_gen(2, tree=tree3))]=rpois(lambda=mu1,n=6) 
plot.phylo(tree3)

# okay and now you want to split cells into twins 
# you have 3 * 2^3 = 24 cells 
a = 0.2 # asymmetry parameter
nr_twin1 = round(a * 3*2^3) # nr of cells to twin1 
# select the last nodes 
tree3_df = data.frame(fortify(tree3))
twin_nodes = tree3_df %>% filter(branch == max(tree3_df$branch)) %>% dplyr::select(node) %>% unlist()
twin1_nodes = sample(twin_nodes, nr_twin1)

plot.phylo(tree3)
nodelabels(twin_nodes, twin_nodes, col= 'blue')  

plot.phylo(tree3)
nodelabels(twin1_nodes, twin1_nodes, col= 'purple')  

# okay so now what I could do is basically have a parameter where I select cells on the same lineage 
# this is proxy to how closely related cells stick together after cell division (~cell mixing)
# I guess an option would be to have a parameter cell_mixing T or F, and if cell_mixing=F, then
twin_nodes = tree3_df %>% filter(branch == max(tree3_df$branch)) %>% dplyr::select(node) %>% unlist()
twin_nodes = twin_nodes[1:8] # only sample from the a 8 nodes which were generated by one ICM cell 
twin1_nodes = sample(twin_nodes, nr_twin1)
plot.phylo(tree3)
nodelabels(twin_nodes, twin_nodes, col= 'blue')  
plot.phylo(tree3)
nodelabels(twin1_nodes, twin1_nodes, col= 'purple')  

# I guess now we can calculate the number of different mutations shared or twin-specific 
# assign mutations to each branch 
# but then this gives you mutation burden, you are not really tracking which cell inherits which mutation 
# anyway let's go with this for now and we will see what we can do 
mu1=2
mu2=1
tree3$edge.length = rpois(lambda=mu2,n=nrow(tree3$edge)) # add mutations onto each branch of the tree (sample from Poisson distribution with lambda = mutation rate after ZGA)
tree3$edge.length[tree3$edge[,2]%in%c(find_nodes_gen(1, tree=tree3),find_nodes_gen(2, tree=tree3))]=rpois(lambda=mu1,n=6) 
plot.phylo(tree3)
nodelabels(twin1_nodes, twin1_nodes, col= 'purple')  



